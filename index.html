<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=fOEonugfEEW2k3BWBOC73NapAJZzj7dMnhijhzEj3ec');.lst-kix_ulmbfu30nvo1-0>li:before{content:"" counter(lst-ctn-kix_ulmbfu30nvo1-0,decimal) ". "}.lst-kix_ulmbfu30nvo1-4>li{counter-increment:lst-ctn-kix_ulmbfu30nvo1-4}.lst-kix_6i2fpngegtnf-6>li:before{content:"\0025cf  "}.lst-kix_6i2fpngegtnf-8>li:before{content:"\0025a0  "}.lst-kix_6i2fpngegtnf-5>li:before{content:"\0025a0  "}.lst-kix_ulmbfu30nvo1-1>li:before{content:"" counter(lst-ctn-kix_ulmbfu30nvo1-1,lower-latin) ". "}.lst-kix_6i2fpngegtnf-3>li:before{content:"\0025cf  "}.lst-kix_ulmbfu30nvo1-4>li:before{content:"" counter(lst-ctn-kix_ulmbfu30nvo1-4,lower-latin) ". "}ol.lst-kix_ulmbfu30nvo1-7{list-style-type:none}ol.lst-kix_64cd5xamur6c-3.start{counter-reset:lst-ctn-kix_64cd5xamur6c-3 0}ol.lst-kix_ulmbfu30nvo1-4.start{counter-reset:lst-ctn-kix_ulmbfu30nvo1-4 0}ol.lst-kix_ulmbfu30nvo1-8{list-style-type:none}ol.lst-kix_64cd5xamur6c-0.start{counter-reset:lst-ctn-kix_64cd5xamur6c-0 0}.lst-kix_6i2fpngegtnf-2>li:before{content:"\0025a0  "}.lst-kix_6i2fpngegtnf-4>li:before{content:"\0025cb  "}ol.lst-kix_ulmbfu30nvo1-5{list-style-type:none}.lst-kix_64cd5xamur6c-7>li:before{content:"" counter(lst-ctn-kix_64cd5xamur6c-7,lower-latin) ". "}ol.lst-kix_ulmbfu30nvo1-6{list-style-type:none}.lst-kix_ulmbfu30nvo1-2>li:before{content:"" counter(lst-ctn-kix_ulmbfu30nvo1-2,lower-roman) ". "}ol.lst-kix_ulmbfu30nvo1-0.start{counter-reset:lst-ctn-kix_ulmbfu30nvo1-0 0}.lst-kix_ulmbfu30nvo1-3>li:before{content:"" counter(lst-ctn-kix_ulmbfu30nvo1-3,decimal) ". "}.lst-kix_64cd5xamur6c-6>li:before{content:"" counter(lst-ctn-kix_64cd5xamur6c-6,decimal) ". "}.lst-kix_6i2fpngegtnf-0>li:before{content:"\0025cf  "}.lst-kix_6i2fpngegtnf-1>li:before{content:"\0025cb  "}.lst-kix_ulmbfu30nvo1-5>li{counter-increment:lst-ctn-kix_ulmbfu30nvo1-5}ol.lst-kix_64cd5xamur6c-7.start{counter-reset:lst-ctn-kix_64cd5xamur6c-7 0}.lst-kix_64cd5xamur6c-8>li:before{content:"" counter(lst-ctn-kix_64cd5xamur6c-8,lower-roman) ". "}.lst-kix_64cd5xamur6c-8>li{counter-increment:lst-ctn-kix_64cd5xamur6c-8}.lst-kix_64cd5xamur6c-2>li{counter-increment:lst-ctn-kix_64cd5xamur6c-2}ol.lst-kix_ulmbfu30nvo1-7.start{counter-reset:lst-ctn-kix_ulmbfu30nvo1-7 0}ol.lst-kix_64cd5xamur6c-4.start{counter-reset:lst-ctn-kix_64cd5xamur6c-4 0}.lst-kix_64cd5xamur6c-6>li{counter-increment:lst-ctn-kix_64cd5xamur6c-6}ol.lst-kix_ulmbfu30nvo1-8.start{counter-reset:lst-ctn-kix_ulmbfu30nvo1-8 0}.lst-kix_64cd5xamur6c-0>li:before{content:"" counter(lst-ctn-kix_64cd5xamur6c-0,decimal) ". "}.lst-kix_64cd5xamur6c-3>li{counter-increment:lst-ctn-kix_64cd5xamur6c-3}ol.lst-kix_ulmbfu30nvo1-0{list-style-type:none}ol.lst-kix_64cd5xamur6c-1.start{counter-reset:lst-ctn-kix_64cd5xamur6c-1 0}.lst-kix_64cd5xamur6c-3>li:before{content:"" counter(lst-ctn-kix_64cd5xamur6c-3,decimal) ". "}.lst-kix_64cd5xamur6c-5>li:before{content:"" counter(lst-ctn-kix_64cd5xamur6c-5,lower-roman) ". "}ol.lst-kix_ulmbfu30nvo1-3{list-style-type:none}ol.lst-kix_ulmbfu30nvo1-4{list-style-type:none}ol.lst-kix_ulmbfu30nvo1-1{list-style-type:none}.lst-kix_64cd5xamur6c-4>li:before{content:"" counter(lst-ctn-kix_64cd5xamur6c-4,lower-latin) ". "}ol.lst-kix_ulmbfu30nvo1-1.start{counter-reset:lst-ctn-kix_ulmbfu30nvo1-1 0}ol.lst-kix_ulmbfu30nvo1-2{list-style-type:none}.lst-kix_64cd5xamur6c-0>li{counter-increment:lst-ctn-kix_64cd5xamur6c-0}.lst-kix_64cd5xamur6c-1>li:before{content:"" counter(lst-ctn-kix_64cd5xamur6c-1,lower-latin) ". "}.lst-kix_64cd5xamur6c-2>li:before{content:"" counter(lst-ctn-kix_64cd5xamur6c-2,lower-roman) ". "}.lst-kix_6i2fpngegtnf-7>li:before{content:"\0025cb  "}.lst-kix_ulmbfu30nvo1-7>li{counter-increment:lst-ctn-kix_ulmbfu30nvo1-7}ol.lst-kix_64cd5xamur6c-5.start{counter-reset:lst-ctn-kix_64cd5xamur6c-5 0}.lst-kix_ulmbfu30nvo1-1>li{counter-increment:lst-ctn-kix_ulmbfu30nvo1-1}ol.lst-kix_64cd5xamur6c-8.start{counter-reset:lst-ctn-kix_64cd5xamur6c-8 0}ol.lst-kix_ulmbfu30nvo1-5.start{counter-reset:lst-ctn-kix_ulmbfu30nvo1-5 0}ol.lst-kix_64cd5xamur6c-2.start{counter-reset:lst-ctn-kix_64cd5xamur6c-2 0}.lst-kix_ulmbfu30nvo1-2>li{counter-increment:lst-ctn-kix_ulmbfu30nvo1-2}.lst-kix_64cd5xamur6c-5>li{counter-increment:lst-ctn-kix_64cd5xamur6c-5}ol.lst-kix_ulmbfu30nvo1-2.start{counter-reset:lst-ctn-kix_ulmbfu30nvo1-2 0}ol.lst-kix_64cd5xamur6c-5{list-style-type:none}ul.lst-kix_6i2fpngegtnf-2{list-style-type:none}ol.lst-kix_64cd5xamur6c-6{list-style-type:none}ul.lst-kix_6i2fpngegtnf-1{list-style-type:none}ol.lst-kix_64cd5xamur6c-3{list-style-type:none}ul.lst-kix_6i2fpngegtnf-4{list-style-type:none}ol.lst-kix_64cd5xamur6c-4{list-style-type:none}ul.lst-kix_6i2fpngegtnf-3{list-style-type:none}ol.lst-kix_64cd5xamur6c-1{list-style-type:none}ul.lst-kix_6i2fpngegtnf-6{list-style-type:none}ol.lst-kix_64cd5xamur6c-2{list-style-type:none}ul.lst-kix_6i2fpngegtnf-5{list-style-type:none}ul.lst-kix_6i2fpngegtnf-8{list-style-type:none}ol.lst-kix_ulmbfu30nvo1-3.start{counter-reset:lst-ctn-kix_ulmbfu30nvo1-3 0}ol.lst-kix_64cd5xamur6c-0{list-style-type:none}ul.lst-kix_6i2fpngegtnf-7{list-style-type:none}.lst-kix_ulmbfu30nvo1-0>li{counter-increment:lst-ctn-kix_ulmbfu30nvo1-0}.lst-kix_ulmbfu30nvo1-3>li{counter-increment:lst-ctn-kix_ulmbfu30nvo1-3}.lst-kix_ulmbfu30nvo1-6>li{counter-increment:lst-ctn-kix_ulmbfu30nvo1-6}.lst-kix_ulmbfu30nvo1-8>li{counter-increment:lst-ctn-kix_ulmbfu30nvo1-8}ol.lst-kix_64cd5xamur6c-7{list-style-type:none}ul.lst-kix_6i2fpngegtnf-0{list-style-type:none}.lst-kix_64cd5xamur6c-1>li{counter-increment:lst-ctn-kix_64cd5xamur6c-1}ol.lst-kix_64cd5xamur6c-8{list-style-type:none}.lst-kix_ulmbfu30nvo1-8>li:before{content:"" counter(lst-ctn-kix_ulmbfu30nvo1-8,lower-roman) ". "}.lst-kix_64cd5xamur6c-4>li{counter-increment:lst-ctn-kix_64cd5xamur6c-4}ol.lst-kix_ulmbfu30nvo1-6.start{counter-reset:lst-ctn-kix_ulmbfu30nvo1-6 0}.lst-kix_64cd5xamur6c-7>li{counter-increment:lst-ctn-kix_64cd5xamur6c-7}.lst-kix_ulmbfu30nvo1-5>li:before{content:"" counter(lst-ctn-kix_ulmbfu30nvo1-5,lower-roman) ". "}.lst-kix_ulmbfu30nvo1-6>li:before{content:"" counter(lst-ctn-kix_ulmbfu30nvo1-6,decimal) ". "}.lst-kix_ulmbfu30nvo1-7>li:before{content:"" counter(lst-ctn-kix_ulmbfu30nvo1-7,lower-latin) ". "}ol.lst-kix_64cd5xamur6c-6.start{counter-reset:lst-ctn-kix_64cd5xamur6c-6 0}ol{margin:0;padding:0}table td,table th{padding:0}.c51{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;background-color:#d0e0e3;border-left-style:solid;border-bottom-width:1pt;width:73.5pt;border-top-color:#000000;border-bottom-style:solid}.c47{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;background-color:#ea9999;border-left-style:solid;border-bottom-width:1pt;width:46.5pt;border-top-color:#000000;border-bottom-style:solid}.c5{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;background-color:#ea9999;border-left-style:solid;border-bottom-width:1pt;width:47.2pt;border-top-color:#000000;border-bottom-style:solid}.c40{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;background-color:#b6d7a8;border-left-style:solid;border-bottom-width:1pt;width:47.2pt;border-top-color:#000000;border-bottom-style:solid}.c29{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;background-color:#b6d7a8;border-left-style:solid;border-bottom-width:1pt;width:46.5pt;border-top-color:#000000;border-bottom-style:solid}.c38{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:21pt;border-top-color:#000000;border-bottom-style:solid}.c3{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:468pt;border-top-color:#000000;border-bottom-style:solid}.c25{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:325.5pt;border-top-color:#000000;border-bottom-style:solid}.c28{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:75pt;border-top-color:#000000;border-bottom-style:solid}.c27{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:221.2pt;border-top-color:#000000;border-bottom-style:solid}.c18{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:66.8pt;border-top-color:#000000;border-bottom-style:solid}.c44{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:67.5pt;border-top-color:#000000;border-bottom-style:solid}.c37{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:153.8pt;border-top-color:#000000;border-bottom-style:solid}.c67{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:47.2pt;border-top-color:#000000;border-bottom-style:solid}.c11{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:90.8pt;border-top-color:#000000;border-bottom-style:solid}.c58{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:154.5pt;border-top-color:#000000;border-bottom-style:solid}.c2{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:180pt;border-top-color:#000000;border-bottom-style:solid}.c55{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:73.5pt;border-top-color:#000000;border-bottom-style:solid}.c26{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:181.5pt;border-top-color:#000000;border-bottom-style:solid}.c9{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:171pt;border-top-color:#000000;border-bottom-style:solid}.c64{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:46.5pt;border-top-color:#000000;border-bottom-style:solid}.c33{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:20.2pt;border-top-color:#000000;border-bottom-style:solid}.c45{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:195.8pt;border-top-color:#000000;border-bottom-style:solid}.c22{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:23.2pt;border-top-color:#000000;border-bottom-style:solid}.c30{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:217.5pt;border-top-color:#000000;border-bottom-style:solid}.c35{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:180.8pt;border-top-color:#000000;border-bottom-style:solid}.c36{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:76.5pt;border-top-color:#000000;border-bottom-style:solid}.c32{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:20pt;font-family:"Arial";font-style:normal}.c4{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c21{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:16pt;font-family:"Arial";font-style:normal}.c7{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Consolas";font-style:normal}.c41{color:#bf9000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:18pt;font-family:"Corsiva";font-style:normal}.c34{color:#000000;text-decoration:none;vertical-align:baseline;font-size:16pt;font-family:"Arial";font-style:normal}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c16{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:right}.c61{padding-top:0pt;padding-bottom:3pt;line-height:1.15;page-break-after:avoid;text-align:left}.c23{padding-top:20pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;text-align:left}.c24{text-decoration-skip-ink:none;font-size:9pt;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c8{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;text-align:left}.c52{color:#000000;font-weight:400;font-size:26pt;font-family:"Arial"}.c65{color:#6aa84f;font-weight:400;font-size:12pt;font-family:"Corsiva"}.c13{border-spacing:0;border-collapse:collapse;margin-right:auto}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c39{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c19{background-color:#ffffff;font-size:12pt;color:#222222}.c59{background-color:#ffffff;color:#24292e;font-size:10pt}.c17{font-family:"Corsiva";color:#cc4125;font-weight:400}.c49{text-decoration:none;vertical-align:baseline;font-style:normal}.c43{background-color:#ffffff;font-size:12pt;color:#24292e}.c14{font-family:"Corsiva";color:#7f6000;font-weight:400}.c57{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c20{padding:0;margin:0}.c46{margin-left:36pt;padding-left:0pt}.c54{color:#000000;font-size:9pt}.c48{color:inherit;text-decoration:inherit}.c12{font-weight:400;font-family:"Consolas"}.c68{font-weight:400;font-family:"Arial"}.c63{height:17pt}.c62{background-color:#ffffff}.c56{height:25pt}.c60{height:13pt}.c15{height:0pt}.c31{font-style:italic}.c42{height:19pt}.c53{height:16pt}.c50{height:15pt}.c10{font-weight:700}.c66{background-color:#ffe599}.c6{height:11pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c57"><p class="c61 title" id="h.j2qjp9e83ehb"><span class="c52 c49">Go-li language user manual</span></p><p class="c16"><span class="c41">func Compar(a, b *) int</span></p><p class="c16"><span class="c49 c65">func Transpose(matrix [], stride int) (o [], newstride int)</span></p><p class="c16"><span class="c17">func Sort(</span><span class="c14">compar func(*,*), </span><span class="c17">slice []</span><span class="c14">)</span></p><h1 class="c23" id="h.45sxoma3v6w7"><span class="c32">Introduction</span></h1><p class="c0"><span class="c4">Go Li also known as go language improved is a prototype programming language to test a limited &ldquo;generics&rdquo; features added to go language. It allows to use parameterized functions also known as generic functions. Each such a function is parametrized by exactly one type, known as the wildcard type.</span></p><h1 class="c23" id="h.ebri7rwcmh6b"><span class="c32">Installation</span></h1><p class="c0"><span>Visit </span><span class="c39"><a class="c48" href="https://www.google.com/url?q=http://go-li.github.io/xgtest.html%23&amp;sa=D&amp;ust=1522502682529000">http://go-li.github.io/xgtest.html#</a></span><span>&nbsp;to use an online playground. Or download a source to source translator from the url </span><span class="c39"><a class="c48" href="https://www.google.com/url?q=https://github.com/go-li/transpiler&amp;sa=D&amp;ust=1522502682529000">https://github.com/go-li/transpiler</a></span><span class="c4">. This translator is able to translate source code packages from go-li to golang. It is invoked ./transpiler -P /source/arbitrary/package/directory -T /destination/package/directory.</span></p><p class="c0"><span>Alternatively, you can try the </span><span class="c39"><a class="c48" href="#h.ogy240mc4mkn">experimental gccgo based compiler below</a></span><span class="c4">.</span></p><h1 class="c23" id="h.ugxude7w3fcx"><span class="c32">Basic usage</span></h1><a id="t.53d239482978dde6421ffa7b4e20e692d570ccdb"></a><a id="t.0"></a><table class="c13"><tbody><tr class="c15"><td class="c3" colspan="1" rowspan="1"><p class="c1"><span class="c7">package main<br><br>import &quot;fmt&quot;<br><br>func reverse(args ...) [] {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i := 0; i &lt; len(args)/2; i++ {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args[i], args[len(args)-1-i] = args[len(args)-1-i], args[i]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return args<br>}<br><br>func main(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(reverse(&quot;World&quot;, &quot;Hello&quot;))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(reverse(1,2,3,4,5))<br><br>}</span></p></td></tr></tbody></table><p class="c0"><span>In this example we demonstrate a </span><span class="c12">reverse(args ...)</span><span class="c4">&nbsp;generic function. Reverse is a generic function, because it has a parameter of a generic type. </span></p><p class="c0 c6"><span class="c4"></span></p><h1 class="c23" id="h.y46z2fgzdb98"><span class="c32">What is a generic type? What generic types exist?</span></h1><p class="c0"><span class="c4">Generic type is any type that contains the omitted type placeholder, or one that contains another generic type. The following table lists examples of commonly used generic types:</span></p><p class="c0 c6"><span class="c4"></span></p><a id="t.1faca9cf1b64a5447b01efe7e74e6ad34a31c5a3"></a><a id="t.1"></a><table class="c13"><tbody><tr class="c15"><td class="c11" colspan="1" rowspan="1"><p class="c1"><span class="c4">Type</span></p></td><td class="c45" colspan="1" rowspan="1"><p class="c1"><span class="c4">Explanation</span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c1"><span class="c4">Reason why generic</span></p></td></tr><tr class="c15"><td class="c11" colspan="1" rowspan="1"><p class="c1"><span class="c7">*</span></p></td><td class="c45" colspan="1" rowspan="1"><p class="c1"><span class="c4">Generic pointer to wildcard type</span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c1"><span class="c4">Has omitted type placeholder</span></p></td></tr><tr class="c53"><td class="c11" colspan="1" rowspan="1"><p class="c1"><span class="c7">[]</span></p></td><td class="c45" colspan="1" rowspan="1"><p class="c1"><span class="c4">Generic slice of wildcard types</span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c1"><span class="c4">Has omitted type placeholder</span></p></td></tr><tr class="c53"><td class="c11" colspan="1" rowspan="1"><p class="c1"><span class="c7">...</span></p></td><td class="c45" colspan="1" rowspan="1"><p class="c1"><span class="c4">Generic varargs slice</span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c1"><span class="c4">Has omitted type placeholder</span></p></td></tr><tr class="c42"><td class="c11" colspan="1" rowspan="1"><p class="c1"><span class="c7">map[]int</span></p></td><td class="c45" colspan="1" rowspan="1"><p class="c1"><span class="c4">Generic key to integer map</span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c1"><span class="c4">Has omitted type placeholder</span></p></td></tr><tr class="c42"><td class="c11" colspan="1" rowspan="1"><p class="c1"><span class="c7">map[int]</span></p></td><td class="c45" colspan="1" rowspan="1"><p class="c1"><span class="c4">Map containing generic values </span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c1"><span class="c4">Has omitted type placeholder</span></p></td></tr><tr class="c42"><td class="c11" colspan="1" rowspan="1"><p class="c1"><span class="c7">map[]</span></p></td><td class="c45" colspan="1" rowspan="1"><p class="c1"><span class="c4">Map with same key and value type</span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c1"><span class="c4">Has omitted type placeholders</span></p></td></tr><tr class="c42"><td class="c11" colspan="1" rowspan="1"><p class="c1"><span class="c7">chan</span></p></td><td class="c45" colspan="1" rowspan="1"><p class="c1"><span class="c4">Generic channel</span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c1"><span class="c4">Has omitted type placeholder</span></p></td></tr><tr class="c42"><td class="c11" colspan="1" rowspan="1"><p class="c1"><span class="c7">type T *</span></p></td><td class="c45" colspan="1" rowspan="1"><p class="c1"><span class="c4">Named generic type T</span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c0"><span class="c4">Contains omitted type placeholder</span></p></td></tr><tr class="c42"><td class="c11" colspan="1" rowspan="1"><p class="c1"><span class="c7">struct {</span></p><p class="c1"><span class="c7">&nbsp; &nbsp; A *</span></p><p class="c1"><span class="c7">}</span></p></td><td class="c45" colspan="1" rowspan="1"><p class="c1"><span class="c4">Generic struct containing a field with generic pointer type </span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c0"><span class="c4">Contains another generic type</span></p></td></tr><tr class="c42"><td class="c11" colspan="1" rowspan="1"><p class="c1"><span class="c7">func (a *)</span></p></td><td class="c45" colspan="1" rowspan="1"><p class="c1"><span class="c4">Generic callback signature</span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c0"><span class="c4">Contains generic type param/ret</span></p></td></tr><tr class="c42"><td class="c11" colspan="1" rowspan="1"><p class="c1"><span class="c7">func ()(a *)</span></p></td><td class="c45" colspan="1" rowspan="1"><p class="c1"><span class="c4">Generic callback signature</span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c0"><span class="c4">Contains generic type param/ret</span></p></td></tr><tr class="c42"><td class="c11" colspan="1" rowspan="1"><p class="c1"><span class="c7">interface {</span></p><p class="c1"><span class="c7">&nbsp; &nbsp; Foo()(*)</span></p><p class="c1"><span class="c7">}</span></p></td><td class="c45" colspan="1" rowspan="1"><p class="c1"><span class="c4">Generic interface with generic method Foo with generic pointer result type</span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c0"><span class="c4">Contains generic method Foo that has a generic signature due to generic pointer function result.</span></p></td></tr></tbody></table><p class="c0 c6"><span class="c4"></span></p><p class="c0"><span class="c4">Any named type with underlying generic type is also a generic type.</span></p><h1 class="c23" id="h.mmp14qolcry3"><span class="c32">What is a generic function or method?</span></h1><p class="c0"><span class="c4">Each generic function must satisfy the following two rules:</span></p><ol class="c20 lst-kix_64cd5xamur6c-0 start" start="1"><li class="c0 c46"><span class="c4">It must be toplevel (in the file scope). Generic closures are invalid.</span></li><li class="c0 c46"><span>It must have at least one parameter with </span><span class="c39"><a class="c48" href="#h.y46z2fgzdb98">generic type</a></span><span class="c4">. (Generic result is not sufficient.)</span></li></ol><p class="c0"><span>The reason for the first rule is that generic closures are </span><span class="c10">currently disallowed</span><span class="c4">&nbsp;because generic closures are rarely if never useful. The reason for the second rule is that it must be possible to derive the wildcard type from every single callsite. Without a generic function parameter, this is impossible. For this reason top-level functions having only generic typed results and no generic typed parameters are invalid. The following table lists several examples of generic and non generic top-level functions together with validity:</span></p><p class="c0 c6"><span class="c4"></span></p><a id="t.287e5ebbc3c5d1c22cc60411c6a2d5a304e540e0"></a><a id="t.2"></a><table class="c13"><tbody><tr class="c60"><td class="c38" colspan="1" rowspan="1"><p class="c1 c6"><span class="c4"></span></p></td><td class="c25" colspan="1" rowspan="1"><p class="c1"><span class="c4">Function</span></p></td><td class="c55" colspan="1" rowspan="1"><p class="c1"><span class="c4">Genericity</span></p></td><td class="c67" colspan="1" rowspan="1"><p class="c1"><span class="c4">Validity</span></p></td></tr><tr class="c63"><td class="c38" colspan="1" rowspan="1"><p class="c1"><span class="c7">1</span></p></td><td class="c25" colspan="1" rowspan="1"><p class="c1"><span class="c7">func Add1(a int) int { return a + 1; }</span></p></td><td class="c51" colspan="1" rowspan="1"><p class="c1"><span class="c4">not generic</span></p></td><td class="c40" colspan="1" rowspan="1"><p class="c1"><span class="c4">valid</span></p></td></tr><tr class="c15"><td class="c38" colspan="1" rowspan="1"><p class="c1"><span class="c7">2</span></p></td><td class="c25" colspan="1" rowspan="1"><p class="c1"><span class="c7">func passPtr(a *) * { return a; }</span></p></td><td class="c55 c66" colspan="1" rowspan="1"><p class="c1"><span class="c4">generic</span></p></td><td class="c40" colspan="1" rowspan="1"><p class="c1"><span class="c4">valid</span></p></td></tr><tr class="c15"><td class="c38" colspan="1" rowspan="1"><p class="c1"><span class="c7">3</span></p></td><td class="c25" colspan="1" rowspan="1"><p class="c1"><span class="c7">func returnEmptyGslice() [] { return nil; }</span></p></td><td class="c51" colspan="1" rowspan="1"><p class="c1"><span class="c4">not generic</span></p></td><td class="c5" colspan="1" rowspan="1"><p class="c1"><span class="c4">invalid</span></p></td></tr><tr class="c15"><td class="c38" colspan="1" rowspan="1"><p class="c1"><span class="c7">4</span></p></td><td class="c25" colspan="1" rowspan="1"><p class="c1"><span class="c7">func tryGclosure() { func(*){}((*int)(nil)); }</span></p></td><td class="c51" colspan="1" rowspan="1"><p class="c1"><span class="c4">not generic</span></p></td><td class="c5" colspan="1" rowspan="1"><p class="c1"><span class="c4">invalid</span></p></td></tr></tbody></table><p class="c0 c6"><span class="c4"></span></p><p class="c0"><span class="c4">Suppose we want to return nil slice of arbitrary type? How do we fix the function 3? It&rsquo;s simple, we add some generic typed parameter. When we call the function, we can pass a typed nil.</span></p><p class="c0 c6"><span class="c4"></span></p><a id="t.96c6ae96a494c14927641586982a29570ee9a87e"></a><a id="t.3"></a><table class="c13"><tbody><tr class="c15"><td class="c3" colspan="1" rowspan="1"><p class="c1"><span class="c7">package main</span></p><p class="c1 c6"><span class="c7"></span></p><p class="c1"><span class="c12">func returnEmptyGslice(</span><span class="c12">_ *</span><span class="c7">) [] {</span></p><p class="c1"><span class="c7">&nbsp; &nbsp; &nbsp; &nbsp; return nil;</span></p><p class="c1"><span class="c7">}</span></p><p class="c1 c6"><span class="c7"></span></p><p class="c1"><span class="c7">func main() {</span></p><p class="c1"><span class="c7">&nbsp; &nbsp; &nbsp; &nbsp; intslice := returnEmptyGslice((*int)(nil)) &nbsp; // wildcard is int</span></p><p class="c1"><span class="c7">&nbsp; &nbsp; &nbsp; &nbsp; byteslice := returnEmptyGslice((*byte)(nil)) // wildcard is byte</span></p><p class="c1"><span class="c7">&nbsp; &nbsp; &nbsp; &nbsp; println(len(intslice))</span></p><p class="c1"><span class="c7">&nbsp; &nbsp; &nbsp; &nbsp; println(len(byteslice))</span></p><p class="c1"><span class="c7">}</span></p></td></tr></tbody></table><h1 class="c23" id="h.easowdop3wa7"><span class="c32">Calling top-level generic functions</span></h1><p class="c0"><span class="c4">When calling top-level generic function, for every call site, there are these rules:</span></p><ol class="c20 lst-kix_ulmbfu30nvo1-0 start" start="1"><li class="c0 c46"><span class="c4">It must be possible to derive the wildcard type</span></li><li class="c0 c46"><span class="c4">It must be possible to derive the concrete named return types for every generic named return type (if any).</span></li><li class="c0 c46"><span class="c4">There can not be any wildcard type conflict (with the exception of interface{} wildcard and concrete varargs passed as &hellip; typed variadic parameters )</span></li></ol><p class="c0"><span class="c4">In the following wildcard type derivation examples, we are going to call this top-level function:</span></p><a id="t.4b368ad6c0485ab419077a09a1ce025d43e582c5"></a><a id="t.4"></a><table class="c13"><tbody><tr class="c15"><td class="c3" colspan="1" rowspan="1"><p class="c1"><span class="c7">func Wildcards(a *, b func(*,*), c []) {</span></p><p class="c1"><span class="c7">}</span></p></td></tr></tbody></table><p class="c0 c6"><span class="c4"></span></p><p class="c0"><span class="c4">We are going to call Wildcards function using these callsites. We assume the function Wildcards is called from a non-generic function. Validity and explanation why follow the call site code:</span></p><a id="t.0b60526bd3a2a52594f1317db72c20d3f023d634"></a><a id="t.5"></a><table class="c13"><tbody><tr class="c50"><td class="c33" colspan="1" rowspan="1"><p class="c1 c6"><span class="c4"></span></p></td><td class="c27" colspan="1" rowspan="1"><p class="c1"><span class="c4">Call site</span></p></td><td class="c64" colspan="1" rowspan="1"><p class="c1"><span class="c4">Validity</span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c1"><span class="c4">Explanation</span></p></td></tr><tr class="c15"><td class="c33" colspan="1" rowspan="1"><p class="c1"><span class="c4">1</span></p></td><td class="c27" colspan="1" rowspan="1"><p class="c1"><span class="c49 c54 c12">Wildcards(nil, nil, nil)</span></p></td><td class="c47" colspan="1" rowspan="1"><p class="c1"><span class="c4">invalid</span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c1"><span class="c4">Untyped nil derived from all args</span></p></td></tr><tr class="c15"><td class="c33" colspan="1" rowspan="1"><p class="c1"><span class="c4">2</span></p></td><td class="c27" colspan="1" rowspan="1"><p class="c1"><span class="c49 c54 c12">Wildcards((*int)(nil), nil, nil)</span></p></td><td class="c29" colspan="1" rowspan="1"><p class="c1"><span class="c4">valid</span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c1"><span>Wildcard is </span><span class="c10">int</span><span class="c4">&nbsp;(from param a)</span></p></td></tr><tr class="c15"><td class="c33" colspan="1" rowspan="1"><p class="c1"><span class="c4">3</span></p></td><td class="c27" colspan="1" rowspan="1"><p class="c1"><span class="c49 c54 c12">Wildcards(nil, func(*int,*int){}, nil)</span></p></td><td class="c29" colspan="1" rowspan="1"><p class="c1"><span class="c4">valid</span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c1"><span>Wildcard is </span><span class="c10">int</span><span class="c4">&nbsp;(from param b)</span></p></td></tr><tr class="c15"><td class="c33" colspan="1" rowspan="1"><p class="c1"><span class="c4">4</span></p></td><td class="c27" colspan="1" rowspan="1"><p class="c1"><span class="c49 c54 c12">Wildcards(nil, nil, []byte{})</span></p></td><td class="c29" colspan="1" rowspan="1"><p class="c1"><span class="c4">valid</span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c1"><span>Wildcard is </span><span class="c10">byte</span><span class="c4">&nbsp;(from param c)</span></p></td></tr><tr class="c50"><td class="c33" colspan="1" rowspan="1"><p class="c1"><span class="c4">5</span></p></td><td class="c27" colspan="1" rowspan="1"><p class="c1"><span class="c49 c54 c12">Wildcards((*int)(nil), nil, ([]byte)(nil))</span></p></td><td class="c47" colspan="1" rowspan="1"><p class="c1"><span class="c4">invalid</span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c1"><span>Wildcard is </span><span class="c10">int</span><span>&nbsp;(from a) or </span><span class="c10">byte</span><span class="c4">&nbsp;(from c) [rule 3]</span></p></td></tr></tbody></table><p class="c0 c6"><span class="c4"></span></p><p class="c0"><span class="c4">What follows is we are going to call top-level generic function Varargs.</span></p><a id="t.b04f708a4e075bcdf0abde890bc3aae4140616ee"></a><a id="t.6"></a><table class="c13"><tbody><tr class="c15"><td class="c3" colspan="1" rowspan="1"><p class="c1"><span class="c7">func Varargs(a *, b ...) {</span></p><p class="c1"><span class="c7">}</span></p></td></tr></tbody></table><p class="c0 c6"><span class="c4"></span></p><p class="c0 c6"><span class="c4"></span></p><a id="t.ed79b682febcd686511c8eabb32388b0bb46b794"></a><a id="t.7"></a><table class="c13"><tbody><tr class="c50"><td class="c22" colspan="1" rowspan="1"><p class="c1 c6"><span class="c4"></span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c1"><span class="c4">Call site</span></p></td><td class="c64" colspan="1" rowspan="1"><p class="c1"><span class="c4">Validity</span></p></td><td class="c35" colspan="1" rowspan="1"><p class="c1"><span class="c4">Explanation</span></p></td></tr><tr class="c15"><td class="c22" colspan="1" rowspan="1"><p class="c1"><span class="c4">6</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c1"><span class="c49 c54 c12">Varargs(nil, 0)</span></p></td><td class="c29" colspan="1" rowspan="1"><p class="c1"><span class="c4">valid</span></p></td><td class="c35" colspan="1" rowspan="1"><p class="c1"><span>Wildcard is </span><span class="c10">int</span><span class="c4">&nbsp;(from param b)</span></p></td></tr><tr class="c56"><td class="c22" colspan="1" rowspan="1"><p class="c1"><span class="c4">7</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c1"><span class="c49 c54 c12">Varargs(nil, 0, &ldquo;hello&rdquo;)</span></p></td><td class="c47" colspan="1" rowspan="1"><p class="c1"><span class="c4">invalid</span></p></td><td class="c35" colspan="1" rowspan="1"><p class="c1"><span>Wildcard is </span><span class="c10">int</span><span>&nbsp;(from b) or </span><span class="c10">string</span><span class="c4">&nbsp;(from b) [rule 3]</span></p></td></tr><tr class="c15"><td class="c22" colspan="1" rowspan="1"><p class="c1"><span class="c4">8</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c1"><span class="c49 c12 c54">Varargs((*int)(nil))</span></p></td><td class="c29" colspan="1" rowspan="1"><p class="c1"><span class="c4">valid</span></p></td><td class="c35" colspan="1" rowspan="1"><p class="c1"><span>Wildcard is </span><span class="c10">int</span><span class="c4">&nbsp;(from param a)</span></p></td></tr><tr class="c15"><td class="c22" colspan="1" rowspan="1"><p class="c1"><span class="c4">9</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c1"><span class="c49 c54 c12">Varargs(nil)</span></p></td><td class="c47" colspan="1" rowspan="1"><p class="c1"><span class="c4">invalid</span></p></td><td class="c35" colspan="1" rowspan="1"><p class="c1"><span class="c4">Untyped nil derived from a [rule 1]</span></p></td></tr><tr class="c50"><td class="c22" colspan="1" rowspan="1"><p class="c1"><span class="c4">10</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c1"><span class="c49 c54 c12">Varargs((interface{})(nil), 0, &ldquo;hello&rdquo;)</span></p></td><td class="c29" colspan="1" rowspan="1"><p class="c1"><span class="c4">valid</span></p></td><td class="c35" colspan="1" rowspan="1"><p class="c1"><span>Wildcard is </span><span class="c10">interface{}</span><span>&nbsp;(from a) and </span><span class="c10">interface{}</span><span class="c4">&nbsp;(from b) [rule 3]</span></p></td></tr></tbody></table><p class="c0 c6"><span class="c4"></span></p><h2 class="c8" id="h.va0c04jtrz5"><span class="c21">Generic named type callsites with concrete type mappings</span></h2><p class="c0"><span class="c4">It&rsquo;s possible to pass named concrete types as named generic parameters. This demonstrates this feature. In this scenario, from argument x and parameter a it can be derived that the type Tint is the concrete type that implements the generic type T</span></p><p class="c0 c6"><span class="c4"></span></p><p class="c0 c6"><span class="c4"></span></p><p class="c0 c6"><span class="c4"></span></p><a id="t.25b071930c9fc684cad92329ea815043fce81921"></a><a id="t.8"></a><table class="c13"><tbody><tr class="c15"><td class="c3" colspan="1" rowspan="1"><p class="c1"><span class="c7">package main</span></p><p class="c1 c6"><span class="c7"></span></p><p class="c1"><span class="c7">type T *</span></p><p class="c1 c6"><span class="c7"></span></p><p class="c1"><span class="c7">type Tint *int</span></p><p class="c1 c6"><span class="c7"></span></p><p class="c1"><span class="c7">func accept(a T) T {</span></p><p class="c1"><span class="c7">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return a</span></p><p class="c1"><span class="c7">}</span></p><p class="c1 c6"><span class="c7"></span></p><p class="c1"><span class="c7">func main() {</span></p><p class="c1"><span class="c7">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var x Tint</span></p><p class="c1"><span class="c7">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = accept(x)</span></p><p class="c1"><span class="c12">}</span></p></td></tr></tbody></table><p class="c0 c6"><span class="c4"></span></p><p class="c0"><span class="c4">The following demo is invalid. The translator has no way to know what concrete type should the variable y in main have. In other words, the possibility that generic type Y shall become concrete type Yint is unrelated to the fact that the generic type X becomes the concrete type Xint.</span></p><p class="c0 c6"><span class="c4"></span></p><a id="t.e33695527e6e27a107d0b54eb449db819ad718a4"></a><a id="t.9"></a><table class="c13"><tbody><tr class="c15"><td class="c3" colspan="1" rowspan="1"><p class="c1"><span class="c7">// This demo does not compile</span></p><p class="c1"><span class="c7">package main</span></p><p class="c1 c6"><span class="c7"></span></p><p class="c1"><span class="c7">type X *</span></p><p class="c1"><span class="c7">type Y *</span></p><p class="c1 c6"><span class="c7"></span></p><p class="c1 c6"><span class="c7"></span></p><p class="c1"><span class="c7">type Xint *int</span></p><p class="c1"><span class="c7">type Yint *int</span></p><p class="c1 c6"><span class="c7"></span></p><p class="c1 c6"><span class="c7"></span></p><p class="c1"><span class="c7">func reject(a X) Y {</span></p><p class="c1"><span class="c7">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return a</span></p><p class="c1"><span class="c7">}</span></p><p class="c1 c6"><span class="c7"></span></p><p class="c1"><span class="c7">func main() {</span></p><p class="c1"><span class="c7">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var x Xint</span></p><p class="c1"><span class="c7">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y := reject(x)</span></p><p class="c1"><span class="c7">}</span></p></td></tr></tbody></table><p class="c0 c6"><span class="c4"></span></p><h1 class="c23" id="h.4i68p0fyfo7p"><span class="c32">Operations allowed in generic functions</span></h1><h2 class="c8" id="h.vr1wd69m987g"><span class="c21">Examples of compile time type safe operations</span></h2><a id="t.931be6878ece9b308ba1377376d29f1c4ccd8394"></a><a id="t.10"></a><table class="c13"><tbody><tr class="c15"><td class="c9" colspan="1" rowspan="1"><p class="c1"><span class="c4">Operation</span></p></td><td class="c37" colspan="1" rowspan="1"><p class="c1"><span class="c4">Operation name</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c1"><span class="c4">Type of a</span></p></td><td class="c36" colspan="1" rowspan="1"><p class="c1"><span class="c4">Type of b</span></p></td></tr><tr class="c15"><td class="c9" colspan="1" rowspan="1"><p class="c1"><span class="c7">*a = *b</span></p></td><td class="c37" colspan="1" rowspan="1"><p class="c1"><span class="c4">Copy generic value</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c1"><span class="c7">*</span></p></td><td class="c36" colspan="1" rowspan="1"><p class="c1"><span class="c7">*</span></p></td></tr><tr class="c15"><td class="c9" colspan="1" rowspan="1"><p class="c1"><span class="c7">*a, *b = *b, *a</span></p></td><td class="c37" colspan="1" rowspan="1"><p class="c1"><span class="c4">Swap generic value</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c1"><span class="c7">*</span></p></td><td class="c36" colspan="1" rowspan="1"><p class="c1"><span class="c7">*</span></p></td></tr><tr class="c15"><td class="c9" colspan="1" rowspan="1"><p class="c1"><span class="c7">*a = b[0]</span></p></td><td class="c37" colspan="1" rowspan="1"><p class="c1"><span class="c4">Copy slice value</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c1"><span class="c7">*</span></p></td><td class="c36" colspan="1" rowspan="1"><p class="c1"><span class="c7">[]</span></p></td></tr><tr class="c15"><td class="c9" colspan="1" rowspan="1"><p class="c1"><span class="c7">a = &amp;b[0]</span></p></td><td class="c37" colspan="1" rowspan="1"><p class="c1"><span class="c4">Set pointer to a slice value</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c1"><span class="c7">*</span></p></td><td class="c36" colspan="1" rowspan="1"><p class="c1"><span class="c7">[]</span></p></td></tr><tr class="c15"><td class="c9" colspan="1" rowspan="1"><p class="c1"><span class="c7">a = b</span></p></td><td class="c37" colspan="1" rowspan="1"><p class="c1"><span class="c4">Copy slice header</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c1"><span class="c7">[]</span></p></td><td class="c36" colspan="1" rowspan="1"><p class="c1"><span class="c7">[]</span></p></td></tr><tr class="c15"><td class="c9" colspan="1" rowspan="1"><p class="c1"><span class="c7">a[4] = b[5]</span></p></td><td class="c37" colspan="1" rowspan="1"><p class="c1"><span class="c4">Copy slice value</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c1"><span class="c7">[]</span></p></td><td class="c36" colspan="1" rowspan="1"><p class="c1"><span class="c7">[]</span></p></td></tr><tr class="c15"><td class="c9" colspan="1" rowspan="1"><p class="c1"><span class="c7">a = make([], b)</span></p></td><td class="c37" colspan="1" rowspan="1"><p class="c1"><span class="c4">Make a generic slice</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c1"><span class="c7">[]</span></p></td><td class="c36" colspan="1" rowspan="1"><p class="c1"><span class="c7">int</span></p></td></tr><tr class="c15"><td class="c9" colspan="1" rowspan="1"><p class="c1"><span class="c7">a = b[4:5]</span></p></td><td class="c37" colspan="1" rowspan="1"><p class="c1"><span class="c4">Reslice a generic slice</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c1"><span class="c7">[]</span></p></td><td class="c36" colspan="1" rowspan="1"><p class="c1"><span class="c7">[]</span></p></td></tr><tr class="c15"><td class="c9" colspan="1" rowspan="1"><p class="c1"><span class="c7">_ = a[*b]</span></p></td><td class="c37" colspan="1" rowspan="1"><p class="c1"><span class="c4">Wildcard keyed map lookup</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c1"><span class="c7">map[]bool</span></p></td><td class="c36" colspan="1" rowspan="1"><p class="c1"><span class="c7">*</span></p></td></tr><tr class="c15"><td class="c9" colspan="1" rowspan="1"><p class="c1"><span class="c7">a = make(map[int], b)</span></p></td><td class="c37" colspan="1" rowspan="1"><p class="c1"><span class="c4">Make a wildcard valued map</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c1"><span class="c7">map[int]</span></p></td><td class="c36" colspan="1" rowspan="1"><p class="c1"><span class="c7">int</span></p></td></tr><tr class="c15"><td class="c9" colspan="1" rowspan="1"><p class="c1"><span class="c7">*a = b[5]</span></p></td><td class="c37" colspan="1" rowspan="1"><p class="c1"><span class="c4">Copy map value to ptr elem.</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c1"><span class="c7">*</span></p></td><td class="c36" colspan="1" rowspan="1"><p class="c1"><span class="c7">map[int]</span></p></td></tr><tr class="c15"><td class="c9" colspan="1" rowspan="1"><p class="c1"><span class="c7">a(b, nil)</span></p></td><td class="c37" colspan="1" rowspan="1"><p class="c1"><span class="c4">Run generic callback or func</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c1"><span class="c7">func(*,*)</span></p></td><td class="c36" colspan="1" rowspan="1"><p class="c1"><span class="c7">*</span></p></td></tr><tr class="c15"><td class="c9" colspan="1" rowspan="1"><p class="c1"><span class="c7">a = b((*)(nil))</span></p></td><td class="c37" colspan="1" rowspan="1"><p class="c1"><span class="c4">Pass wildcard type to call</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c1"><span class="c7">*</span></p></td><td class="c36" colspan="1" rowspan="1"><p class="c1"><span class="c7">func(*)(*)</span></p></td></tr><tr class="c15"><td class="c9" colspan="1" rowspan="1"><p class="c1"><span class="c7">a &lt;- *b</span></p></td><td class="c37" colspan="1" rowspan="1"><p class="c1"><span class="c4">Send on generic chan</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c1"><span class="c7">chan</span></p></td><td class="c36" colspan="1" rowspan="1"><p class="c1"><span class="c7">*</span></p></td></tr><tr class="c15"><td class="c9" colspan="1" rowspan="1"><p class="c1"><span class="c7">a = b</span></p></td><td class="c37" colspan="1" rowspan="1"><p class="c1"><span class="c4">copy variable to interface{}</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c1"><span class="c7">interface{}</span></p></td><td class="c36" colspan="1" rowspan="1"><p class="c1"><span class="c7">Any generic</span></p></td></tr></tbody></table><h2 class="c8" id="h.1bknvfqaxpyq"><span>Examples of run time &ldquo;type safe&rdquo; operations</span></h2><a id="t.2f837c185674749b83b3246b40156ba414a8f26d"></a><a id="t.11"></a><table class="c13"><tbody><tr class="c15"><td class="c9" colspan="1" rowspan="1"><p class="c1"><span class="c7">Operation</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c1"><span class="c4">Why not compile time safe</span></p></td><td class="c44" colspan="1" rowspan="1"><p class="c1"><span class="c7">Type of a</span></p></td><td class="c28" colspan="1" rowspan="1"><p class="c1"><span class="c7">Type of b</span></p></td></tr><tr class="c15"><td class="c9" colspan="1" rowspan="1"><p class="c1"><span class="c7">a = make(map[]bool, b)</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c1"><span class="c4">Panic due incomparable key</span></p></td><td class="c44" colspan="1" rowspan="1"><p class="c1"><span class="c7">map[]bool</span></p></td><td class="c28" colspan="1" rowspan="1"><p class="c1"><span class="c7">int</span></p></td></tr><tr class="c15"><td class="c9" colspan="1" rowspan="1"><p class="c1"><span class="c7">((interface{})(a)).(*int)</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c1"><span class="c4">a might point to non-int type</span></p></td><td class="c44" colspan="1" rowspan="1"><p class="c1"><span class="c7">*</span></p></td><td class="c28" colspan="1" rowspan="1"><p class="c1 c6"><span class="c7"></span></p></td></tr></tbody></table><h1 class="c23" id="h.mmmrr3t076q8"><span class="c32">So what can we use this &ldquo;generics&rdquo; for</span></h1><p class="c0"><span class="c4">This is not a well studied area. A surprising uses of this mechanism could be discovered. Let&rsquo;s first try to summarise what is known to be possible today. By possible we mean it&rsquo;s done in a compile time type safe way.</span></p><p class="c0 c6"><span class="c4"></span></p><p class="c0"><span class="c4">Sorting of slices. Binary heap built from a slice. Byte array keyed arbitrary valued sorted sets (AVL tree). Max(a,b), Min(a,b) functions for arbitrary types. Double slice arbitrary keyed arbitrary valued hashtable that is only 20% slower than builtin map. Type safe doubly linked list. Leaky pool. Ring buffer &ldquo;queue&rdquo; made from a slice. Map[foo]struct{} set. float64/float32 agnostic math functions like transpose, matrix multiply by constant.</span></p><p class="c0 c6"><span class="c4"></span></p><p class="c0"><span class="c4">Not compile time type safe:</span></p><p class="c0 c6"><span class="c4"></span></p><p class="c0"><span class="c4">Deduplicate a slice by throwing things into a map. Convert a slice using function to arbitrary another type slice.</span></p><p class="c0 c6"><span class="c4"></span></p><p class="c0"><span class="c4">Unknown:</span></p><p class="c0 c6"><span class="c4"></span></p><p class="c0"><span>Call traits. Graphs for instance </span><span class="c43">immediate dominator</span><span>. Bimap. Multiple indexes over a collections. </span><span class="c31">data accessors</span><span class="c62">&nbsp;in Dietmar K&uuml;hl&#39;s Masters Thesis on generic graph algorithms. Caches. </span><span class="c43">Compile-time type-safe </span><span class="c49 c12 c59">sync.Pool. Set operations over collections.</span></p><h1 class="c23" id="h.9d3ze7gw8e0j"><span class="c32">Errors and solutions</span></h1><h2 class="c8" id="h.1tgd5wxyeopl"><span class="c21">undetermined wildcard from missing varargs in call to foo</span></h2><p class="c0"><span class="c4">You have a varargs only function like:</span></p><a id="t.b4090bed77a5f578b6a74a86b2bab3b73b044366"></a><a id="t.12"></a><table class="c13"><tbody><tr class="c15"><td class="c3" colspan="1" rowspan="1"><p class="c1"><span class="c7">func foo(args ...) {</span></p><p class="c1"><span class="c7">}</span></p></td></tr></tbody></table><p class="c0"><span>You can&rsquo;t call it like: </span><span class="c7">foo()</span></p><p class="c0"><span>You need to provide at least one argument from which the wildcard type can be determined. For instance you can pass typed nil to the function: </span><span class="c12">foo((*int)(nil)) </span><span>. Or you can pass some concrete (the same) types, for instance </span><span class="c12">foo(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;) . </span><span>Or </span><span class="c7">foo(1,2,3)</span></p><h2 class="c8" id="h.tzloftnor48o"><span class="c21">cannot convert nil (untyped nil value) to untyped void</span></h2><p class="c0"><span>You can&rsquo;t call it like: </span><span class="c12">foo(nil)</span></p><p class="c0"><span>You need to provide some argument from which the wildcard type can be determined. For instance you can pass typed nil to the function: </span><span class="c7">foo((*int)(nil))</span></p><h2 class="c8" id="h.81mpa6fyarbt"><span class="c21">wildcard cannot be untyped nil (untyped nil value)</span></h2><p class="c0"><span class="c4">You have a generic pointer accepting function like:</span></p><a id="t.f521d0f80dae3fb7bd6148ff50ead5bf5c9eaaf0"></a><a id="t.13"></a><table class="c13"><tbody><tr class="c15"><td class="c3" colspan="1" rowspan="1"><p class="c1"><span class="c7">func accept(ptr *) {</span></p><p class="c1"><span class="c7">}</span></p></td></tr></tbody></table><p class="c0"><span>You can&rsquo;t call it like: </span><span class="c7">accept(nil)</span></p><p class="c0"><span>You need to provide some argument from which the wildcard type can be determined. For instance you can pass typed nil to the function: </span><span class="c7">accept((*int)(nil))</span></p><p class="c0 c6"><span class="c7"></span></p><p class="c61 title" id="h.mh9ecxluyqyt"><span class="c49 c52">GCCGO-li user manual</span></p><h1 class="c23" id="h.ogy240mc4mkn"><span class="c32">Installation - x86-64 Linux only</span></h1><p class="c0"><span class="c10">1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>Download the gccgo-8.0.1-006.tar.xz from the generics slack chat channel. The URL of the channel is: </span><span class="c39"><a class="c48" href="https://www.google.com/url?q=https://gophers.slack.com/messages/C88U9BFDZ/&amp;sa=D&amp;ust=1522502682578000">https://gophers.slack.com/messages/C88U9BFDZ/</a></span></p><p class="c0"><span class="c10">2.</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;After downloading, verify the authenticity of the file</span><span>.</span></p><p class="c0"><span class="c7">$ sha256sum gccgo-8.0.1-006.tar.xz </span></p><p class="c0"><span class="c7">337c04797b7c2c0fc7e586b309fad19cac864dfd9f7ef4420f0f427123db3ccd &nbsp;gccgo-8.0.1-006.tar.xz</span></p><p class="c0"><span class="c10">3.</span><span class="c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unpack the archive ether from the file browser or using command:</span></p><p class="c0"><span class="c12 c19">$ tar -xf </span><span class="c12">gccgo-8.0.1-006.tar.xz</span></p><p class="c0"><span class="c4">You can unpack it to any location. But the rest of the guide assumes you moved the unpacked gccgo folder to /opt. The file structure should be like this:</span></p><a id="t.fbbf2aedab0d2a536b16460dcb8bdaf9d2261da7"></a><a id="t.14"></a><table class="c13"><tbody><tr class="c15"><td class="c3" colspan="1" rowspan="1"><p class="c1"><span class="c7">/opt/</span></p><p class="c1"><span class="c7">&#9500;&#9472;&#9472; gccgo</span></p><p class="c1"><span class="c7">&#9474; &nbsp; &#9500;&#9472;&#9472; bin</span></p><p class="c1"><span class="c7">&#9474; &nbsp; &#9474; &nbsp; &#9500;&#9472;&#9472; c++</span></p><p class="c1"><span class="c7">&#9474; &nbsp; &#9474; &nbsp; &#9500;&#9472;&#9472; cpp</span></p><p class="c1"><span class="c7">&#9474; &nbsp; &#9474; &nbsp; &#9500;&#9472;&#9472; g++</span></p><p class="c1"><span class="c7">&#9474; &nbsp; &#9474; &nbsp; &#9500;&#9472;&#9472; gcc</span></p><p class="c1"><span class="c7">&#9474; &nbsp; &#9474; &nbsp; &#9500;&#9472;&#9472; gcc-ar</span></p><p class="c1"><span class="c7">...</span></p></td></tr></tbody></table><p class="c0"><span>Now it&rsquo;s installed. You can skip to </span><span class="c39"><a class="c48" href="#h.elwydl6efgk4">testing the installation</a></span><span>.</span></p><h1 class="c23" id="h.bht0r331govv"><span class="c32">Installation from source</span></h1><p class="c0"><span class="c4">You need gcc source from gcc.gnu.org, and the generics patches from github.</span></p><p class="c0"><span class="c4">For example I&rsquo;ve downloaded gcc-8-20180325.tar.xz and these patches:</span></p><p class="c0"><span class="c24"><a class="c48" href="https://www.google.com/url?q=https://github.com/go-li/gofrontend/commit/1f227e14dd73acff48a8909bbef0ff4b9da73f53.patch&amp;sa=D&amp;ust=1522502682581000">https://github.com/go-li/gofrontend/commit/1f227e14dd73acff48a8909bbef0ff4b9da73f53.patch</a></span></p><p class="c0"><span class="c24"><a class="c48" href="https://www.google.com/url?q=https://github.com/go-li/gofrontend/commit/b448b08e273af75ffd007b76230306c88d9e6f50.patch&amp;sa=D&amp;ust=1522502682581000">https://github.com/go-li/gofrontend/commit/b448b08e273af75ffd007b76230306c88d9e6f50.patch</a></span></p><p class="c0"><span class="c4">You also need the backend patch, known as patch zero.patch:</span></p><p class="c0"><span class="c39"><a class="c48" href="https://www.google.com/url?q=https://pastebin.com/raw/VhNtCvbY&amp;sa=D&amp;ust=1522502682582000">https://pastebin.com/raw/VhNtCvbY</a></span></p><p class="c0"><span class="c4">Create a folder gccgo and inside a folder emptydir and gofrontend. Unpack the gcc archive to emptydir. In gofrontend create two folders go and libgo. Put the patches to gofrontend.</span></p><p class="c0"><span class="c4">This guide assumes you are building in /tmp/gccgo. If you plan to shut down your computer, pick an alternate location for example in your home folder.</span></p><p class="c0 c6"><span class="c4"></span></p><a id="t.d029b87624271c0e66566d439f0aeac2ceddf0b9"></a><a id="t.15"></a><table class="c13"><tbody><tr class="c15"><td class="c3" colspan="1" rowspan="1"><p class="c1"><span class="c7">/tmp/gccgo/</span></p><p class="c1"><span class="c7">&#9500;&#9472;&#9472; emptydir</span></p><p class="c1"><span class="c7">&#9474; &nbsp; &#9500;&#9472;&#9472; gcc-8-20180325</span></p><p class="c1"><span class="c7">&#9474; &nbsp; ...</span></p><p class="c1"><span class="c7">&#9500;&#9472;&#9472; gofrontend</span></p><p class="c1"><span class="c7">&#9474; &nbsp; &#9500;&#9472;&#9472; go</span></p><p class="c1"><span class="c7">&#9474; &nbsp; &#9500;&#9472;&#9472; libgo</span></p><p class="c1"><span class="c7">&#9474; &nbsp; &#9500;&#9472;&#9472; arrayaccess.patch</span></p><p class="c1"><span class="c7">&#9474; &nbsp; &#9500;&#9472;&#9472; generics.patch</span></p><p class="c1"><span class="c7">&#9474; &nbsp; &#9500;&#9472;&#9472; zero.patch</span></p><p class="c1"><span class="c7">...</span></p></td></tr></tbody></table><p class="c0"><span class="c4">Copy over everything from /tmp/gccgo/emptydir/gcc-8-20180325/gcc/go/gofrontend/ to /tmp/gccgo/gofrontend/go/. Also copy everything from /tmp/gccgo/emptydir/gcc-8-20180325/libgo/ to /tmp/gccgo/gofrontend/libgo/</span></p><p class="c0 c6"><span class="c4"></span></p><p class="c0"><span class="c4">Now run this in the gofrontend folder to apply the changes from github:</span></p><p class="c0 c6"><span class="c4"></span></p><a id="t.60d2e519fced37007c0ebdc5dda1a9c90f2ac7e6"></a><a id="t.16"></a><table class="c13"><tbody><tr class="c15"><td class="c3" colspan="1" rowspan="1"><p class="c1"><span class="c7">patch -p1 &lt; arrayaccess.patch</span></p><p class="c1"><span class="c7">patch -p1 &lt; generics.patch</span></p></td></tr></tbody></table><p class="c0 c6"><span class="c4"></span></p><p class="c0"><span class="c4">In folder emptydir run this recipe</span></p><a id="t.5b2be50e758bf3d6b32a84dc4495b3c707a9c413"></a><a id="t.17"></a><table class="c13"><tbody><tr class="c15"><td class="c3" colspan="1" rowspan="1"><p class="c1"><span class="c7">cd gcc-8-20180325/</span></p><p class="c1"><span class="c7">patch -p1 &lt; ../../gofrontend/zero.patch</span></p><p class="c1"><span class="c7">rm -rf gcc/go/gofrontend</span></p><p class="c1"><span class="c7">ln -s /tmp/gccgo/gofrontend/go gcc/go/gofrontend</span></p><p class="c1"><span class="c7">mkdir libgotmp/</span></p><p class="c1"><span class="c7">mv libgo/go libgotmp/</span></p><p class="c1"><span class="c7">mv libgo/mics libgotmp/</span></p><p class="c1"><span class="c7">mv libgo/runtime libgotmp/</span></p><p class="c1"><span class="c7">rm -rf libgo</span></p><p class="c1"><span class="c7">mkdir libgo/</span></p><p class="c1"><span class="c7">mv libgotmp/go libgo/</span></p><p class="c1"><span class="c7">mv libgotmp/mics libgo/</span></p><p class="c1"><span class="c7">mv libgotmp/runtime libgo/</span></p><p class="c1"><span class="c7">mkdir libgo/testsuite/</span></p><p class="c1"><span class="c7">mkdir libgo/config/</span></p><p class="c1"><span class="c7">cd libgo/testsuite</span></p><p class="c1"><span class="c7">for f in /tmp/gccgo/gofrontend/libgo/testsuite/*; do ln -s $f `basename $f`; done</span></p><p class="c1"><span class="c7">cd ..</span></p><p class="c1"><span class="c7">cd config/</span></p><p class="c1"><span class="c7">for f in /tmp/gccgo/gofrontend/libgo/config/*; do ln -s $f `basename $f`; done</span></p><p class="c1"><span class="c7">cd ..</span></p><p class="c1"><span class="c7">for f in /tmp/gccgo/gofrontend/libgo/*; do ln -s $f `basename $f`; done</span></p><p class="c1"><span class="c7">cd ..</span></p><p class="c1"><span class="c7">cd ..</span></p></td></tr></tbody></table><p class="c0"><span class="c4">Now, in emptydir, you can configure.</span></p><p class="c0 c6"><span class="c4"></span></p><a id="t.031f32715bc45d625e68c4b3b8a8db2210b53ea6"></a><a id="t.18"></a><table class="c13"><tbody><tr class="c15"><td class="c3" colspan="1" rowspan="1"><p class="c1"><span class="c7">CFLAGS=&#39;-O3&#39; LDFLAGS=&#39;-s -w -O3&#39; CXXFLAGS=&#39;-O3&#39; gcc-8-20180325/configure &nbsp;--prefix=/opt/gccgo --disable-bootstrap --disable-libgomp &nbsp;--without-ppl --without-isl --without-cloog --disable-libada --disable-multilib --enable-__cxa_atexit &nbsp;--enable-gnu-indirect-function --enable-languages=c,c++,go --disable-libsanitizer</span></p></td></tr></tbody></table><p class="c0"><span class="c4">Now after configure went ok, run make (this could take up to two hours!!)</span></p><p class="c0 c6"><span class="c4"></span></p><a id="t.0b9d805f862b4cbdbbb3066f8dcaddf31bc3fc24"></a><a id="t.19"></a><table class="c13"><tbody><tr class="c15"><td class="c3" colspan="1" rowspan="1"><p class="c1"><span class="c7">make -j 4</span></p></td></tr></tbody></table><p class="c0 c6"><span class="c4"></span></p><p class="c0"><span class="c4">Once that&rsquo;s succeeded, run sudo make install. Your gccgo will appear in /opt/gccgo/</span></p><h1 class="c23" id="h.elwydl6efgk4"><span class="c32">Testing</span></h1><p class="c0"><span>You can download basic test programs to determine if the generics work. These programs are available at </span><span class="c39"><a class="c48" href="https://www.google.com/url?q=https://github.com/go-li/demo&amp;sa=D&amp;ust=1522502682588000">https://github.com/go-li/demo</a></span><span class="c4">.</span></p><p class="c0 c6"><span class="c4"></span></p><a id="t.64938f62757a7bad273b0644be8b92681bb0ce5a"></a><a id="t.20"></a><table class="c13"><tbody><tr class="c15"><td class="c3" colspan="1" rowspan="1"><p class="c1"><span class="c7">$ cd /tmp/</span></p><p class="c1 c6"><span class="c7"></span></p><p class="c1"><span class="c12">$ git clone </span><span class="c39 c12"><a class="c48" href="https://www.google.com/url?q=https://github.com/go-li/demo.git&amp;sa=D&amp;ust=1522502682589000">https://github.com/go-li/demo.git</a></span></p><p class="c1 c6"><span class="c7"></span></p><p class="c1"><span class="c7">Cloning into &#39;demo&#39;...</span></p><p class="c1"><span class="c7">remote: Counting objects: 169, done.</span></p><p class="c1"><span class="c7">remote: Compressing objects: 100% (3/3), done.</span></p><p class="c1"><span class="c7">remote: Total 169 (delta 0), reused 1 (delta 0), pack-reused 166</span></p><p class="c1"><span class="c7">Receiving objects: 100% (169/169), 50.62 KiB | 0 bytes/s, done.</span></p><p class="c1"><span class="c7">Resolving deltas: 100% (81/81), done.</span></p><p class="c1"><span class="c7">Checking connectivity... done.</span></p><p class="c1 c6"><span class="c7"></span></p><p class="c1"><span class="c7">$ /opt/gccgo/bin/gccgo demo/bubblesort.go -static-libgo</span></p><p class="c1"><span class="c7">$ ./a.out </span></p><p class="c1"><span class="c12">47,35,7,5,3,</span></p></td></tr></tbody></table><p class="c0 c6"><span class="c4"></span></p><p class="c0"><span class="c4">This tested the bubblesort demo. Other demos from this repo should work as well.</span></p><h1 class="c23" id="h.sll93yxa1qh0"><span class="c32">Gccgo bugs</span></h1><p class="c0"><span class="c4">This gccgo frontend has many bugs. However this does not necessarily mean that your programs will fail in production. If your program successfully compiles, it&rsquo;s usually safe to run it. These bugs limit the possible generics features that you can use in your program. If you use a buggy feature, your program will fail to compile or the compiler will crash.</span></p><h2 class="c8" id="h.6lgjfvb18srg"><span class="c21">Varargs does not work</span></h2><p class="c0"><span>You cannot create and use generic varargs functions. The demo from the top of this document does not work.</span></p><h2 class="c8" id="h.o98h0y4r0us6"><span class="c21">Unsafe packages cannot use generics</span></h2><p class="c0"><span class="c4">If you import unsafe, your generic functions won&rsquo;t be recognized to be generic. Therefore you should never import unsafe while using this proposal. </span></p><h2 class="c8" id="h.8wmmtp31i5r7"><span class="c21">Import/export does not work for generics</span></h2><p class="c0"><span class="c4">If you create a generic function with a capitalized name, you are asking for a trouble. It will never work.</span></p><h2 class="c8" id="h.k8tx1zlcx18m"><span class="c21">Wildcard substitution bugs</span></h2><p class="c0"><span class="c4">The type returned by a generic-type-result function is sometimes not the one it should be. This is because wildcard substitution is buggy. In particular parameter-related named types are not returned and not substituted into the result type. You can workaround by casting the function result variable to the right type manually. Also if you use unusual return types like a generic map it will crash because substitution is not implemented.</span></p><h2 class="c8" id="h.q3tcy16uu5ah"><span class="c21">Only a few generic operations are supported</span></h2><p class="c0"><span class="c4">Only operations supported is copying wildcard-typed value using a pointer:</span></p><p class="c0"><span class="c4">*dst = *src</span></p><p class="c0"><span class="c4">And a generic slice index address dereference expression</span></p><p class="c0"><span class="c4">pointer = &amp;slice[5]</span></p><p class="c0"><span class="c4">Furthermore you can make generic slices:</span></p><p class="c0"><span class="c4">make([], 4)</span></p><h2 class="c8" id="h.voiw1k61i6ht"><span class="c21">Cannot assign generic variables to interface{}</span></h2><p class="c0"><span class="c4">This doesn&rsquo;t work and never will.</span></p><h2 class="c8" id="h.e0v3hrg7zika"><span class="c21">Cannot cast interface{} to a generic type, like slice := foo.([])</span></h2><p class="c0"><span class="c4">This doesn&rsquo;t work and never will.</span></p><h2 class="c8" id="h.sljx4k64rzuo"><span class="c21">The protection against using of generic types outside of generic context is missing</span></h2><p class="c0"><span class="c4">You should always first develop and test your generic program using the transpiler / playground. Only when you get no errors, you can attempt to compile using gccgo. If you use generic types outside of generic context (top-level generic function) there is no safety and no guarantees.</span></p><p class="c0 c6"><span class="c4"></span></p><p class="c0 c6"><span class="c4"></span></p><p class="c0 c6"><span class="c4"></span></p></body></html>